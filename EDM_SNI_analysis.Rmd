---
title: "Dynamic Species Interactions in the San Nicolas Island Kelp Forest"
subtitle: "Empirical dynamic modeling analysis"
author: "Owen Liu"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: pdf_document
bibliography: citation_bibtex.bib
editor_options: 
  chunk_output_type: inline
---

```{r global_options, include=F,message=F}
require(knitr)
knitr::opts_chunk$set(echo = FALSE,warning=FALSE,message = FALSE,results = 'asis')
```

```{r setup, include=FALSE,message=F}
# Load required packages
require(tidyverse)
require(here)
require(rEDM)
require(quantreg)
require(knitr)
require(kableExtra)
require(extrafont)
require(png)
require(ggridges)
require(GGally)
require(ggalt)
require(ggsci)
require(sna)
require(network)
require(gridExtra)
require(RANN)

# plot theme
plot_theme <-   theme_minimal()+
  theme(text=element_text(family="Rockwell",size=12,color="black"),
        legend.text = element_text(size=14),
        axis.title=element_text(family="Rockwell",size=14),
        axis.text=element_text(family="Rockwell",size=8),
        strip.background = element_rect(colour="black"),
        panel.border = element_rect(color="black",fill=NA))

theme_set(plot_theme)
```

## Introduction

This document accompanies the manuscript "..." The following analyses lay out the building blocks of the empirical dynamic modeling approach [@Deyle2016; @Chang2017] that produced the final version of the analyses in the paper.

In the analysis that follows, in each step that involves a new type of EDM method, its logic will be briefly described.  However, keep in mind that the basic theory behind each individual method is the same: We use some dynamic information (from single or multiple time series) to reconstruct a shadow attractor/manifold, and then use the properties of that manifold to make predictions or estimate interactions.

## 1. Variables in the Data

### The San Nicolas Island Dataset

San Nicolas Island is a small, remote island situated about 100 kilometers offshore from southern California.  The island itself is small, about 14 kilometer long and 5 km wide. The data in the analysis is from a sampling station on the western end of San Nicolas Island. The benthic monitoring data herein have been collected more or less every six months for more than 35 years by the USGS and its Western Ecological Research Center (USGS-WERC), and in 2013 the datasets were made available publicly through Ecological Archives:

Michael C. Kenner, James A. Estes, M. Tim Tinker, James L. Bodkin, Robert K. Cowen, Christopher Harrold, Brian B. Hatfield, Mark Novak, Andrew Rassweiler, and Daniel C. Reed. 2013. A multi-decade time series of kelp forest community structure at San Nicolas Island, California (USA). Ecology 94:2654. http://dx.doi.org/10.1890/13-0561.1

### Physical Oceanographic Data

A body of other research has established that a combination of physical forcing (waves, storms), temperature, and lower frequency climate modes (e.g., El Ninos) have an important influence on the dynamics of kelp forests [@Reed2011; @Cavanaugh2011; @Bell2015,@Young2015]. With these data, we can draw connections between the physical variables and the species interactions in our constrained trophic web.

We have four datasets, already processed into the same time frame (periods) as the SNI benthic monitoring data:

* **[The Multivariate ENSO index (MEI)](http://www.esrl.noaa.gov/psd/enso/mei)**
    + The first principal component of a composite set of physical parameters
    + Positive values of the MEI index are generally associated with El Nino conditions, decreases in wind-driven upwelling, warmer surface waters and nutrient-poor conditions
    + Variable here is the average index value for the four months preceding each Spring or Fall monitoring period (i.e., December to March or June to September, respectively)
    
* **[The Pacific Decadal Oscillation index (PDO)](http://research.jisao.washington.edu/pdo/)**
    + Leading empirical orthogonal function (EOF) of monthly sea surface temperature anomalies (SST-A) over the North Pacific (poleward of 20Â° N) after the global average sea surface temperature has been removed
    + Positive PDO values indicate warmer SST, and nutrient-poor conditions along the western coast of the contiguous United States
    + Aggregated and averaged the same way as MEI
    
* **[The North Pacific Gyre Oscillation (NPGO)](http://www.o3d.org/npgo/)**
    + From [@DiLorenzo2008]
    + Climate pattern that emerges as the 2nd dominant mode of sea surface height variability (2nd EOF SSH) in the Northeast Pacific
    + Better correlated with salinity, nutrients, and chlorophyll than PDO, showing forcing for the planktonic community
    + Strong predictor of upwelling cells south of 38 deg N
    + Aggregated and averaged the same way as MEI and PDO
    
* **Sea surface temperature (SST)**
    + Two sources (to fill in data gaps):
      + Sea surface temperature data directly from Begg Rock and San Nicolas Island buoys, from the [Coastal Data Information Program (CDIP)](http://cdip.ucsd.edu)
      + NOAA's [Optimally Interpolated Sea Surface Temperature](https://www.ncdc.noaa.gov/oisst)
    + Similar to the above, value is an average SST for the four months preceding each period
* **Maximum significant wave height (Hs)**
    + Modeled wave height data from from the [Geophysical Fluid Dynamics Laboratory](http://cmgwindwave.usgsportals.net/) and from Tom Bell at UCSB
    + Signficant wave height is defined as the average height, in meters, of the one third highest waves in the record
    + Instead of an average, value here is the maximum significant wave height of the four months preceding each period. This is meant to capture any large storm events, as well as general level of physical disturbance

Unlike the biological data, where there are unique spatial replicates, the physical data have only one value for each of the 63 monitoring periods, and hence their values are replicated (copied) for each site to match the total length of the biological data.

#### Note about data processing

Usual best practice for EDM is to create normalized time series, so that state-space reconstructions are not distorted by differences in orders of magnitude between variables. In addition, in this study we concatenate each species/station/swath time series into one long time series for each species, while preserving a time indicator (variable 'period') and a site identifier, to ensure that we do not "cross" the boundaries of replicate time series in analyses. Empirical dynamic modeling can use multiple spatial replicates in lieu of increased length of individual time series, to maximize the dynamic information that can be drawn from the system [@Hsieh2008;@Clark2015;@Chang2017].

All raw data is available online or in the included files. We join the monitoring and physical datasets and normalized all time series (see scripts in the "data" folder for details:

```{r load data,message=FALSE,echo=F}
source("data/data preparation scripts/produce_final_data.R")
```

```{r list of variables,echo=F,fig.cap="List of variables"}
tibble(Variable=colnames(westend),Description=c("Monitoring Transect","Monitoring Period","Laminaria Normalized Density",
                                            "Macrocystis pyrifera >1m Normalized Density","Pterygophora Normalized Density",
                                            "Strongylocentrotus purpuratus Normalized Density","Mesocentrotus franciscanus Normalized Density",
                                            "Macrocystis pyrifera <1m Normalized Density","Normalized Multivariate ENSO Index",
                                            "Normalized Pacific Decadal Oscillation","Normalized North Pacific Gyre Oscillation",
                                            "Normalized Maximum Significant Wave Height","Normalized Sea Surface Temperature")) %>%
  knitr::kable()
```


```{r mean density over time, echo=F,message=F}
# black plot theme (for presentations)
# for black plots
plot_theme_black <-   theme_minimal()+
  theme(text=element_text(family="Rockwell",size=12,color="white"),
        line = element_line(color="gray40"),
        legend.text = element_text(size=14),
        axis.title=element_text(family="Rockwell",size=14),
        axis.text=element_text(family="Rockwell",color="white",size=8),
        strip.background = element_rect(colour="black"),
        panel.border = element_rect(color="white",fill=NA),
        panel.background = element_rect(fill="black"),
        plot.background = element_rect(fill="black"),
        panel.grid = element_line(color="gray40"),
        panel.grid.major = element_line(color="gray40"),
        panel.grid.minor = element_line(color="gray40"))

# Species naming key for use in plotting
namekey <- tibble(dataset=c(rep("Benthic density",6),rep("Physical",5)),short=names(westend[3:13]),
                  long=c("Laminaria","Macrocystis >1m","Pterygophora","Purple urchin","Red urchin","Macrocystis <1m","Multivariate ENSO Index","Pacific Decadal Oscillation","North Pacific Gyre Oscillation","Significant Wave Height","Sea Surface Temperature"),plotting=c("L. far","M. pyr","P. cal","S. pur","M. fra","M. pyr (j)","(P) MEI","(P) PDO","(P) NPGO","(P) SWH","(P) SST"))

namekey <- bind_rows(namekey, data_frame(long="NA",dataset="NA",short="const",plotting="Constant")) %>%
  
  # define column "plotting" as a factor so we can later control plotting order on figures
  mutate(plotting=factor(plotting,levels=c("(P) MEI","(P) PDO","(P) NPGO","(P) SWH","(P) SST","M. pyr","M. pyr (j)","L. far","P. cal","S. pur","M. fra","Constant")),
         long=factor(long,levels=c("Macrocystis >1m","Macrocystis <1m","Pterygophora","Laminaria","Purple urchin","Red urchin","Multivariate ENSO Index","Pacific Decadal Oscillation","North Pacific Gyre Oscillation","Significant Wave Height","Sea Surface Temperature","Constant")))

# key relating monitoring period to its year/month
period.key <- data_frame(year=rep(1980:2014,each=12),month=rep(1:12,35),period=c(rep(NA,8),rep(1,4),rep(2:69,each=6)))
periods.first <- period.key %>% 
  distinct(period,.keep_all=T) %>%
  mutate(day=1) %>% #assume all monitoring done on first day of month
  unite(date_str,year,month,day,sep="-") %>%
  mutate(date_str=ymd(date_str))

westend.long <- westend %>%
  gather(key=spp,value=dens,-period,-site,na.rm=T) %>%
  left_join(namekey, by=c("spp"="short"))
westend.meandens <- westend.long %>%
  group_by(spp,period,long) %>% 
  summarise(meandens=mean(dens,na.rm=T),sddens=sd(dens,na.rm=T))%>%
  mutate(lower=meandens-sddens,upper=meandens+sddens)%>%
  left_join(periods.first,by="period") %>%
  ungroup()

# position adjustment for visual clarity
pd <- position_dodge(width=100)
westend.mean_dens_plot <- westend.meandens %>%
  filter(spp %in% c("mac","red","pter","ymac","purp","lam")) %>%
  mutate(type=ifelse(spp %in% c("mac","ymac","pter","lam"),"algae","urchin")) %>%
  ggplot(aes(x=date_str,y=meandens,col=long,linetype=type))+
      geom_hline(yintercept=0)+
      geom_line(lwd=2,alpha=0.8,position=pd)+
      geom_pointrange(aes(ymin=lower,ymax=upper),size=0.3,position=pd)+
      xlab("Year")+ylab("Normalized Density")+
      scale_color_manual(values=c("navyblue","gray50","darkgreen","darkcyan","mediumpurple4","darkred"),
                         guide=guide_legend(title="Species",override.aes = list(size=1)))+
      guides(linetype="none")+
      theme(text = element_text(color="black",size=16),
            axis.title=element_text(size=10),
            legend.position = c(0.15,0.7),
            legend.text = element_text(color="black",size=10),
            panel.border = element_blank())
westend.mean_dens_plot
rm(pd,westend.long,westend.meandens)
# ggsave("plots/normalized_time_series.pdf",h=5,w=7)
```

```{r physical variables timeseries,fig.height=9,fig.width=7}
mei.pdo.npgo.ts.plot <-westend %>%
  ungroup()%>%
  slice(1:63)%>%
  select(period,mei,pdo,npgo)%>%
  gather("driver","value",mei:npgo,-period)%>%
  left_join(namekey, by=c("driver"="short"))%>%
  left_join(periods.first,by="period") %>%
  ggplot(aes(date_str,value,col=driver))+
  geom_line(lwd=1.5)+
  geom_hline(yintercept=0,linetype=2,col="black")+
  labs(title="Physical Drivers: Climate Modes",x="Year",y="Normalized Index Value")+
  theme(axis.title=element_text(size=10))
sst.waves.ts.plot <-westend %>%
  ungroup()%>%
  slice(1:63)%>%
  select(period,sst,waves)%>%
  gather("driver","value",sst,waves,-period)%>%
  left_join(namekey, by=c("driver"="short"))%>%
  left_join(periods.first,by="period") %>%
  ggplot(aes(date_str,value,col=driver))+
  geom_line(lwd=1.5)+
  geom_hline(yintercept=0,linetype=2,col="black")+
  labs(title="Physical Drivers: Temperature and Disturbance",x="Year",y="Normalized Index Value")+
  theme(axis.title=element_text(size=10))
mei.pdo.npgo.ts.plot
sst.waves.ts.plot
# ggsave("plots/climate_ts_plot.png",plot=mei.pdo.npgo.ts.plot,width=7,height=4)
# ggsave("plots/sst_waves_ts_plot.png",plot=sst.waves.ts.plot,width=7,height=4)
lay <- rbind(1,2,3,3)
norm_ts<-grid.arrange(mei.pdo.npgo.ts.plot,sst.waves.ts.plot,westend.mean_dens_plot,layout_matrix=lay)
norm_ts
# ggsave("plots/normalized_time_series.pdf",plot=norm_ts,h=9,w=7)
rm(lay)
```

***

## 2. Establishing Univariate Predictability and Nonlinearity

For each of these time series, we have a few steps to see if they seem appropriate to analyze together with EDM techniques [@Chang2017]. We want to be careful that our state space reconstructions are reliable and represent valid manifolds. In other words, we don't want to rely on simple cross-correlation or the prior knowledge that all these data were collected around the same locations at around the same times. We want evidence that:

1. Variables can be probably embedded (i.e., they show evidence of limited system dimensionality)
2. Variables display state-dependent (nonlinear) dynamics, and therefore that nonlinear (EDM) methods are appropriate for analysis of these data

First, we use simplex projection to get a sense of system dimensionality for each variable, which will also give us an idea of the appropriate embedding dimension to use in later analyses. Then, we explicitly look for evidence of state-dependence and nonlinear dynamics with a prediction horizon test and S-maps.

***
```{r time series segments, include=F}

# segments of the time series (which rows of the data are individual transects?)
westend_segs_sites <- westend %>%
  ungroup() %>%
  mutate(ind = row_number()) %>% 
  group_by(site) %>%
  summarise(first=first(ind),last=last(ind))

# Time series segments without site identifier. We'll need this later
westend.segs <- select(westend_segs_sites,-site)

# species in the study
study_spp <- c("red","purp","lam","pter","mac","ymac")
# physical variables in the study
phys.vars <- c("mei","pdo","npgo","waves","sst")
```

### Simplex Projection and Embedding Dimensions

For each species/variable separately, we will search for signals of deterministic behavior using simplex projection. In simplex projection, we first reconstruct a shadow attractor in *E* dimensions, where *E* is the number of variables, or number of progressive lags of a single variable used in the reconstruction. *E* is called the __*embedding dimension*__. The *E*-length vectors, for example $\it{\bf{x_{t}}} = <x_t,x_{t-1},x_{t-2}>$ are points on the attractor, and the set of *E*-length vectors used for the reconstruction is called the __*library*__. To predict $\it{\bf{x_{t+1}}}$, the simplex algorithm finds the *E* +1 nearest neighbors of $\it{\bf{x_{t}}}$ in the state space, and the prediction $\it{\bf{\hat{x}_{t+1}}}$ is the average of the nearest neighbors' values at $\it{t+1}$, weighted by their Euclidean distance from $\it{\bf{x_{t}}}$ at $\it{t}$. This is the essence of simplex projection: a forecast for a given point in state space is surmised from the forward trajectories of observed nearby points.

In descriptive terms, this is akin to asking, "When the system has been in a state like this before, what happened next?" For example, if we are interested in predicting *Macrocystis* density next year, we might take the current three-year density trend (this year, last year, and the year before, *E*=3) and compare it to a subset of times in the past when successive three-year dynamics looked similar to that set of points. Our prediction, logically, would be the average of that subset, projected foreward one year and weighted by their similarity to the current trend.

By varying the value of *E*, we can determine what the best embedding dimension is for each variable in our analysis, essentially a proxy for the number of variables that best "unfolds" or best represents the shadow attractor. We can measure the skill of an embedding by comparing the estimated forecasts $\it{\bf{\hat{x}_{t+1}}}$ with the observed values $\it{\bf{x_{t+1}}}$, and we report it with $\it{\bf{\rho}}$, the Pearson correlation coefficient between predictions and observations. To avoid in-sample fitting, we use a leave-one-out cross-validation scheme, removing one vector at a time from the library, and predicting its dynamics from the other library vectors. From this exercise, we save the best embedding dimension *E* for each variable, to use in following steps.

```{r univariate simplex westend,fig.width=7,echo=F}
# List to store output of simplex projection
westend.simp.list <- list()

# Run simplex projection for each species at each site, and plot output
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- westend %>% select(matches(spp)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=as.matrix(westend.segs),E=2:15,silent=T) %>%
    mutate(spp=namekey$long[match(spp,namekey$short)])
  westend.simp.list[[spp]] <- out
}

# plot
bind_rows(westend.simp.list) %>%
  ggplot(aes(E,rho,color=spp))+
  geom_line(size=2)+
  facet_wrap(~spp,nrow=2,scales="free_y")+
  labs(x="Embedding Dimension (E)",y=expression(paste("Skill, ",rho)))+
  scale_x_continuous(breaks=seq(0,12,by=2))+
  scale_color_manual(values=c('Macrocystis >1m'="navyblue",'Macrocystis <1m'="gray50",'Pterygophora'="darkgreen",'Laminaria'="darkcyan",'Purple urchin'="mediumpurple4",'Red urchin'="darkred"),name="")+
  guides(color=F)

# Save best embedding dimensions
westend.bestE <- sapply(westend.simp.list,function(x) {
  temp <- x %>% filter(!is.na(rho))
  temp$E[temp$rho==max(temp$rho)]
})

# on looking at the graph, manually change embedding dimension for macrocystis and pterygophora to one that has a very similar
# predictability, but will let us make use of more data

# westend.bestE["ymac"] <- 3
# westend.bestE["pter"] <- 6

rm(spp,dat,out)

# Run simplex for each physical variable
phys.simp.list <- list()
for(i in 1:length(phys.vars)) {
  ind <- phys.vars[i]
  dat <- westend %>% select(matches(ind)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=c(1,63),E=2:10,silent=T) %>%
    mutate(spp=namekey$long[match(ind,namekey$short)])
  phys.simp.list[[ind]] <- out
  westend.simp.list[[ind]] <- out
}

# plot
bind_rows(phys.simp.list) %>%
  ggplot(aes(E,rho))+
  geom_line(size=2)+
  facet_wrap(~spp,nrow=2,scales="free_y")+
  labs(x="Embedding Dimension (E)",y=expression(paste("Skill, ",rho)))+
  scale_x_continuous(breaks=seq(0,10,by=2))+
  guides(color=F)+
  theme(strip.text = element_text(size=8))

rm(ind,dat,out)
phys.bestE <- sapply(phys.simp.list,function(x) {
  temp <- x %>% filter(!is.na(rho))
  temp$E[temp$rho==max(temp$rho)]
})

westend.bestE <- c(westend.bestE,phys.bestE)
```

***

### Prediction Horizon test

We also want to look at prediction decay for each variable, which is one piece of evidence that a dynamic system is nonlinear. Using the best *E* identified in the previous step, we attempt to make predictions increasing far into the future, instead of just one period ahead. A nonlinear system should show decreasing predictive power with increasing prediction horizon[@Sugihara1994]. This phenomenon is a property of deterministic chaos and is analagous to the "butterfly effect", where in a nonlinear system, trajectories in state-space are expected to diverge over time. To examine this effect, we hold *E* constant, and proceed with simplex projection as before, but varying the prediction horizon, $t_p$ (i.e., how many steps ahead we try to predict).

```{r prediction horizon test,message=F,echo=F,fig.width=7,echo=F}
# List to hold prediction horizon results
westend.tp.list <- list()

par(mfrow=c(3,2))
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- westend %>% select(matches(spp)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=as.matrix(westend.segs),silent=T,E=westend.bestE[spp],tp=1:10) %>%
    mutate(spp=namekey$long[match(spp,namekey$short)])
  westend.tp.list[[spp]] <- out
}

#Plot time horizon vs. rho
bind_rows(westend.tp.list) %>%
  ggplot(aes(tp,rho,color=spp))+
  geom_line(size=2)+
  facet_wrap(~spp,nrow=2,scales="free_y")+
  labs(x="Time to Prediction",y=expression(paste("Skill, ",rho)))+
  scale_color_manual(values=c('Macrocystis >1m'="navyblue",'Macrocystis <1m'="gray50",'Pterygophora'="darkgreen",'Laminaria'="darkcyan",'Purple urchin'="mediumpurple4",'Red urchin'="darkred"),name="")+
  scale_x_continuous(breaks=seq(0,10,by=2))+
  guides(color=F)

rm(spp,dat,out)
```

The prediction horizon effect check is promising overall, as most variables decline in predictive ability with increasing time horizon. For *Pterygophora californica*, *Macrocystis* juveniles, and *Laminaria*, there is some evidence of cyclic behavior, in that dynamics are more predictable 6 periods in the future than 3 or 4 periods.

***

### S-maps for Each Species

All of the variables show a decent ability to self-predict, as shown by simplex projection, although some variables require rather high embedding dimensions, indicative of higher-dimensionality dynamics. However, the butterfly effect check is evidence of potential nonlinearity, as all variables decline in predictive ability with time horizon.

We can look for further evidence of nonlinearity with S-maps. S-maps is short for "sequentially weighted global linear maps", and it is similar to simplex projection, except instead of using just the *E* +1 nearest neighbors to make forecasts, S-maps uses all library vectors, and exponentially weights them by their distance to the prediction vector before using linear regression to make a forecast. A parameter, $\it{\bf{\theta}}$, tunes how much greater weight is given to nearby points. If $\it{\bf{\theta}}=0$, all library vectors are weighted equally, and the resulting model is just a vector autogressive (VAR) model of order *E*. However, as $\it{\bf{\theta}}$ is tuned above 0, nearby points in state-space are given more weight in forecasts. Therefore, if model skill $\it{\bf{\rho}}$ increases with increasing $\it{\bf{\theta}}$, it is evidence of nonlinear, state-dependent dynamics.

For a more formal description of the S-maps procedure, see @Sugihara1994 and @Deyle2016.

As a side note, with $\it{\bf{\theta}}>0$, although the set library vectors remains constant, the *weights* given to library vectors for regression is specific to each point in state-space, and therefore a separate linear map is created for each predicted vector. This is why the procedure is called "sequentially weighted global linear maps". Conceptually, as the dynamic system moves along the surface of the attractor, S-maps sequentially computes linear maps to the next point based on nearby points. Mathematically, when making a prediction for a target point $\it{\bf{x^*}}$, each library vector (point on the attractor) $\it{\bf{x}_{k}}$ is given a weight
$$w_{k}=exp\frac{-\theta\mid\mid \it{\bf{x}_{k}}- \it{\bf{x^*}}\mid\mid}{\bar{d}}$$ 
where $\mid\mid \it{\bf{x}_{k}}- \it{\bf{x^*}}\mid\mid$ is the Euclidean distance between the library and target vector, and $\bar{d}$ is the average distance to all library vectors. This weighting is what allows the tuning of nonlinearity by changing the single value $\theta$.

For prediction of each variable using S-maps, we build an attractor for each species using the optimal embedding dimension, *E*, found through our simplex projection above, and we plot the tuning parameter $\it{\bf{\theta}}$ against $\it{\bf{\rho}}$ to investigate whether local, state-dependent weighting of library vectors increases predicability, which would be evidence of nonlinear dynamics.

```{r univariate s_maps westend,fig.width=7,echo=F}
westend.smap.list <- list() # list to store output

par(mfrow=c(3,2))
for(i in 1:length(study_spp)) {
  spp <- study_spp[i]
  dat <- westend %>% select(matches(spp)) %>% as.data.frame()
  out <- s_map(as.numeric(dat[,1]),lib=as.matrix(westend.segs),E=westend.bestE[spp],silent=T) %>%
    mutate(spp=namekey$long[match(spp,namekey$short)])
  westend.smap.list[[spp]] <- out
}

bind_rows(westend.smap.list) %>%
  ggplot(aes(theta,rho,color=spp))+
  geom_line(size=2)+
  facet_wrap(~spp,nrow=2,scales="free_y")+
  labs(x=expression(paste("Nonlinearity (",theta,")")),y=expression(paste("Skill, ",rho)))+
  scale_color_manual(values=c('Macrocystis >1m'="navyblue",'Macrocystis <1m'="gray50",'Pterygophora'="darkgreen",'Laminaria'="darkcyan",'Purple urchin'="mediumpurple4",'Red urchin'="darkred"),name="")+
  scale_x_continuous(breaks=seq(0,8,by=2))+
  guides(color=F)

rm(spp,dat,out)
```

All variables show significantly improved predictive ability with increased $\theta$, suggesting nonlinear dynamics. Together, the simplex, prediction horizon, and S-map results suggest our approach is valid--variables are predictable and nonlinear.

***

## 3. Convergent Cross Mapping

So far, we have established the predictability and nonlinearity of single variables. In this step, we relate the variables to each other, asking whether there is evidence of causal linkages. We do not assume causal interactions--we test for them.

Generalizations of Takens' theorem indicate that if two variables (in our case, species or physical variables) are part of the same dynamic system, their individual dynamics should reflect their relative causal influence [@Sugihara2012; @Deyle2013,@Ye2015,@Clark2015]. In other words, if one variable (for example, giant kelp), is causally forced by another (sea urchins), that forcing should leave a signature on the giant kelp time series. Convergent cross mapping (CCM) tests for causation by using the attractor/manifold built from the time series of one variable to predict another. CCM works just like univariate simplex projection that we did in Step 1, except that separate variables are used for library and prediction vectors. In addition, we normally predict contemporaneous values of the other variable, instead of projecting one step forward (prediction horizon $t_{p}=0$). If the attractor can accurately (based on out-of-sample prediction skill, just as before) predict the dynamics of the second variable, we can claim that the second variable has a causal influence on the first.  In simple terms, the *causal effect of A on B is determined by how well B cross-maps A*. In this way, the inference from cross-mapping is the converse direction of causation. In our example, if sea urchins drive giant kelp,the dynamic information from the urchin time series should be reflected in the kelp dynamics, and kelp should significantly cross-map the urchins.

Cross-mapping can distinguish unidirectional forcing (A forces B but B does not force A) from bi-directional (A and B force each other). It can also resolve transitive causal chains (A causes B causes C, see Fig. 4 in @Sugihara2012). To look for a causal signal, we plot predictive skill  $\it{\bf{\rho}}$ against library size (the number of embedded vectors used to construct the attractor). There are two criteria for CCM to establish causality: 

* First, and most obviously, predictive cross-map skill using all available data should be significantly greater than zero. 
* Second, that predictability should be convergent.  Convergence means that cross-mapped estimates improve with library length, because the attractor is more fully resolved and therefore estimation error should decline. Convergence is key to distinguishing causation from simple or spurious correlation [@Sugihara2012]. If two variables are spuriously correlated and not causally linked, CCM should fail to satisfy this second criterion.

It is also generally true that relative cross-mapping skill of a given variable equates to the strength of causal linkages. That is, if species A cross-maps species B with greater skill than it cross-maps species C, it would suggest that species B is the stronger forcing influence on A.

The CCM algorithm uses a random sampling method to test multiple "versions" of each library size, sampling a subset from the supplied library vectors to establish confidence intervals around prediction skill. We again use leave-one-out cross-validation to prevent in-sample fitting.

***

### Example CCM

Each individual CCM analysis involves looks something like this:

```{r ccm example}
tempE <- westend.bestE['red']
temp <- ccm(westend,lib=as.matrix(westend.segs),pred=as.matrix(westend.segs),E=tempE,lib_column= 'mac',target_column = 'red',lib_sizes = c(10,25,50,75,100,125,150,200,300,400,500),num_samples=100,replace=T,silent=T,RNGseed = 41389)

mac_xmap_red <- temp %>%
  group_by(lib_size)%>%
  summarise(rhomean=mean(rho,na.rm=T),upper=quantile(rho, 0.975),lower=quantile(rho, 0.025))%>%
  ungroup()%>%
  ggplot(aes(lib_size,rhomean))+
  geom_ribbon(aes(ymin=lower,ymax=upper),alpha=0.3,fill="red")+
  geom_line(color="darkorchid3")+
  labs(x="Library Size",y=expression(paste(rho, " (predictive skill)")),title="Macrocystis xmap Red Urchin")

mac_xmap_red
# ggsave("plots/ccm_example.png",plot=mac_xmap_purp,width=6,height=4)
```

```{r ccm all species and physical vars, echo=F,warning=F,fig.width=7}
# Rows hold predicted variables, columns hold forcing variables. There are more columns than rows since the physical variables are included as potential forcing factors.
n_col <- dim(westend)[2]-2
n_row <- dim(westend)[2]-7
col_names <- colnames(westend)[3:(n_col+2)]
row_names <- colnames(westend)[3:(n_row+2)]
westend.xmap_mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## CCM causation criterion 1: cross-map skill greater than zero
# matrix to store a bootstrapped p-value, measuring the probability that a given xmap is greater than zero (calculated as 1 minus the number of positive results for rho divided by the number of iterations)
westend.p1.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## CCM causation criterion 2: evidence for convergence
# similarly, matrix to store a bootstrapped p-value, this time a t-test value between library size 10 and library size 500, to see if the rho at large library is significantly greater than the rho at small library size (i.e., looking for convergence).
westend.p2.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

# if both p1 and p2 are positive, indicate overall significant causal signal
westend.ptot.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## Run CCM for each combination of variables
for(i in 1:n_row) {
  for(j in 1:n_col) {
    if(i != j) {
      # remember, we use the best embedding dimension for the target variable (the variable we're cross-mapping to, i.e. the putative forcing variable)
      tempE=westend.bestE[col_names[j]]
      temp <- ccm(westend,lib=as.matrix(westend.segs),pred=as.matrix(westend.segs),E=tempE,lib_column= 2+i,target_column = 2+j,lib_sizes = c(10,500),num_samples=100,replace=T,silent=T,RNGseed = 41389)
      
     # mean rho at library size 500
      rhomeans <- temp %>% ccm_means()
      westend.xmap_mat[i,j] <- rhomeans$rho[rhomeans$lib_size==500]
      
      # first p-value (greater than zero? at library size 500)
      p1 <- temp %>% filter(lib_size==500) %>% 
        mutate(pos=ifelse(rho>0,1,0)) %>%
        summarise(p=(1-sum(pos)/n()))
      westend.p1.mat[i,j] <- as.numeric(p1)
      
      # second p-value (rho at lib-size 500 greater than rho at lib-size 10? By more than 0.1?)
      p2 <- t.test(temp$rho[temp$lib_size==10],temp$rho[temp$lib_size==500])$p.value
      if((rhomeans$rho[rhomeans$lib_size==500]-rhomeans$rho[rhomeans$lib_size==10])<0.1) p2 <- 1
      westend.p2.mat[i,j] <- as.numeric(p2)
      
      # overall significance (both p1 and p2 signficant at alpha 0.05)
      westend.ptot.mat[i,j] <- ifelse(p1<0.05 & p2<0.05,1,0)
    }
  }
}
rm(n_col,n_row,col_names,row_names,p1,p2,tempE,temp,rhomeans)

# keep only signficant cross-mappings
westend.xmap_mat <- westend.xmap_mat*westend.ptot.mat %>% as.data.frame()
westend.xmap_rast <- westend.xmap_mat %>% 
  mutate(predictee=row.names(westend.xmap_mat)) %>% 
  gather(key=predictor,value=rho,-predictee)

# If rho is zero, replace with NA (no significant causal signal)
westend.xmap_rast$rho[westend.xmap_rast$rho==0] <- NA

# Names for plotting to distinguish biological and physical variables
westend.xmap_rast <- westend.xmap_rast %>% 
  mutate(force.name=namekey$plotting[match(predictor,namekey$short)]) %>%
  mutate(pred.name=namekey$plotting[match(predictee,namekey$short)])

## plot
westend.xmap_all_plot <- ggplot(westend.xmap_rast,aes(x=force.name,y=pred.name,fill=rho)) +
  geom_raster() +
  scale_fill_gradient(low = "#9AFF9A", high = "#548B54", space = "Lab", na.value = "grey50", 
      guide = "colourbar",limits=c(0,0.8),breaks=c(0.2,0.4,0.6,0.8),name=expression(paste(rho, "(skill)"))) +
  geom_text(aes(label=round(rho,2)),family="Rockwell")+
  ggtitle("Kelp Forest Convergent Cross Mapping") +
  xlab("Predictor (Forcing Variable)") +
  ylab("Predicted Variable") +
  theme(text=element_text(color="black"),
        plot.background = element_rect(fill="white"),
        axis.text=element_text(color="black"),
    axis.text.x=element_text(angle = 90, hjust = 1,vjust=0.1),
    panel.border = element_blank())

westend.xmap_all_plot
# ggsave("plots/ccm_all.png",plot=westend.xmap_all_plot,width=7,height=4)
```

The plot shows cross-mapped (predictor, or forcing) variables in the columns, while rows are predicted variables (i.e., columns cause rows). Gray indicates a lack of significant causal signal--failure to satisfy one of the above criteria--and darker colors represent higher cross-map skill.

From this plot, we can make a few observations. The five physical forcing variables are represented in the first five columns, followed by the algae and urchin species. Many physical variables show causal relationships with kelp forest species, especially the North Pacific Gyre Oscillation and maximum wave height (physical disturbance), which show causal links to almost all the biological variables. The NPGO is cross-mapped well by the purple urchin *Strongylocentrotus purpuratus*, while both the NPGO and wave height show a strong influence on adult *Macrocystis* dynamics. So already we are seeing effects that we might expect based on known interactions between physical variables and biological dynamics [@Reed2011;@Bell2015].

Additionally, adult *Macrocystis* itself seems to be the first or second most important driver of the dynamics of all the other species in the tropic web, supporting the decades of research showing the importance of giant kelp as a foundational species [@Graham2007c;@Dayton1985], but further suggesting that its dynamics fundamentally drive the dynamics of other species.  Juvenile, or sporophyte *Macrocystis*, on the other hand, is affected by most of the variables in the system, but does not itself strongly drive dynamics of other species, again an effect we would expect to find. In this system, *Pterygophora californica* also seems to be a strong causal driver of the dynamics of other species in the trophic web.

Both sea urchin species are causally linked to *Macrocystis* density, and they also have a causal effect on one another. This analysis alone, however, does not yet tell us whether the bi-directional interaction between *S. purpuratus* and *M. franciscanus* represents apparent mutualism, apparent competition, or a mixture of both at different times. To further investigate the direction and magnitude of the species interactions themselves, we next build multivariate EDM models that explicitly measure dynamic species interaction strengths.

***

### Interaction Network


The CCM results translated into an empirical interaction web looks like this:

```{r network,fig.height=6,fig.width=6}
# g <- network(connect.mat,vertex.attrnames = names,loops=F)
# g %v% "type" <- c(rep("darkgreen",3),rep("darkorchid1",2),"darkgreen",rep("dodgerblue",5))
# g %v% "labels" <- names
# set.edge.value(g,"weights",edge.weight.mat*3)
# 
# int_net<-ggnet2(g,arrow.size=6,arrow.gap=0.04,color = "type",label=names,label.alpha=0,edge.size="weights")+
#   geom_point(aes(color = color), size = 14, alpha = 0.5) +
#   geom_point(aes(color = color), size = 12)+
#   geom_text(aes(label=label),colour='white',family="Rockwell",size=3)+
#   theme(panel.border = element_rect(colour="white",fill=NA))
# 
# # ggsave("plots/int_net.pdf",plot=int_net)
# int_net

## i graph
require(igraph)

# connections matrix for the network based on the CCM results above
connect.mat <- t(westend.ptot.mat) %>% 
  as.data.frame() %>%
  mutate(mei=rep(0,nrow(.)),pdo=rep(0,nrow(.)),npgo=rep(0,nrow(.)),waves=rep(0,nrow(.)),sst=rep(0,nrow(.)))%>%
  as.matrix()

# edges (arrows) weighted based on CCM rho value
edge.weight.mat <- t(westend.xmap_mat)%>%
  as.data.frame() %>%
  mutate(mei=rep(0,nrow(.)),pdo=rep(0,nrow(.)),npgo=rep(0,nrow(.)),waves=rep(0,nrow(.)),sst=rep(0,nrow(.)))%>%
  as.matrix()
edge.weight.mat[is.na(edge.weight.mat)]<-0
edge.weight.mat

names <- map_chr(colnames(connect.mat), function(x) as.character(namekey$plotting[match(x,namekey$short)]))
names[6] <- "M. pyr\n(j)"
names [7:11] <- c("MEI","PDO","NPGO","SWH","SST")

# initiate the igraph
g2 <- graph.adjacency(connect.mat)

# Vertex labels
V(g2)$name <-names

# label with the number of incoming(outgoing) connections
# vert_in <- sapply(igraph::degree(g2,mode="in"),function(x) paste0("(",x,")"))
# vert_out_in <- paste0(igraph::degree(g2,mode="out"),vert_in)
# V(g2)$label <- paste(sep="\n",V(g2)$name, vert_out_in)
# V(g2)$label[7:11] <- paste(V(g2)$name[7:11])
 
# #vertex coordinates (layout of plot
# crds <- cbind(c(116.0000, 318.0000, 177.0000, 581.0000, 346.0000, 385.0000, 331.1627, 151.8379, 573.0000, 539.0000,  45.0000),c(0.0000, 186.0000, 362.0000, 172.0000,  40.0000, 374.0000, 537.0000, 504.2360, 35.0000, 406.0000, 288.4111))

 
# vector of node colors for plotting
vert.cols <- c(rep("#238B45",3),rep("#BEBADA",2),"#238B45",rep("#8DD3C7",5))

# weighted edges, with width and color
edge.weights <- as.numeric(t(edge.weight.mat))[t(edge.weight.mat) != 0]*5
E(g2)$width <- edge.weights
col.1 <- adjustcolor("#99D8C9", alpha=0.8)
col.2 <- adjustcolor("#006D2C", alpha=0.8)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)
edge.pal <- edge.pal(100)
edge.cols<-round((edge.weights-min(edge.weights))/(max(edge.weights)-min(edge.weights))*100) +1
edge.cols <- edge.pal[edge.cols]

# some edges must be curved to look okay in the graph
curves <- rep(0,40)
curves[c(1,4,13,17,18,21)] <-0.4
curves[c(10,19)] <-0.3
curves[20] <- -0.1
curves[c(6,39)] <- 0.2

#plot to file if uncommented
# png("plots/ccm_network.png",height=500,width=600)
# pdf("plots/ccm_network.pdf")
plot(g2,asp=0.8, vertex.label.color="black",vertex.label.family="Times", vertex.label.cex=0.8, edge.arrow.size=0.8,edge.arrow.width=0.8,vertex.label.font=2, vertex.shape="circle", edge.curved=curves,margin=0,vertex.size=20,rescale=T,edge.lty=1,edge.color=edge.cols,layout=layout_in_circle,vertex.color=vert.cols,vertex.frame.color="black",main="")
# dev.off()
```

In this network, each node represents a variable, and the numbers associated with each are the number of causal connections in the web, outgoing and (incoming). The maximum number of outgoing interactions is 5 (6 total biological variables minus the variable itself), and incoming is 10 (5 biological and 5 physical variables). Algae species are in brown, while the two urchin species are in purple and the physical drivers are in grey. For example, as mentioned above, we can see that young *Macrocystis* (denoted M. pyr (j))is forced by all other variables in the system, but only itself shows a causal forcing on 4 of the 5 other biological variables. Again we can see that while the web is not entirely saturated, there are many unidirectional forcings, and a prevalence of bidirectional causation as well (A forces B *and* B forces A). The adult *Macrocystis* is causally connected to all variables in the analysis.

***

## 4. Multivariate Models Using CCM results

Every EDM method we have used so far involves reconstructing an attractor in state-space and then examining that attractor to make predictions. In Step 2, we used single time series and their lags to build attractors, and examined the attractors for evidence of the degree of dimensionality, predictability, and nonlinearity. In Step 3, we built attractors from one species and searched for the signature of other species' dynamics encoded in those attractors, leading to inferences about causation.

Multivariate models have the same structure, except instead of using single variables to reconstruct the attractors, we use contemporaneous values of multiple variables [@Deyle2016]. That is, instead of library vectors or points in state-space taking the form of, for example, $<x_t,x_{t-1},x_{t-2}>$, they now are formed in true multivariate space, e.g. $<Kelp_{t},Urchin_{t},Nutrients_{t}>$. Using the normalized time series, we will build library vectors that each include the variable we are trying to predict, as well as other causal variables illuminated by our CCM analysis from Step 3. Then we use S-maps as above to forecast the target variable using leave-one-out cross-validation.

```{r causal vars fxn,message=F,echo=F}
# Pull out causal vars from CCM for each species

westend.causal.vars <- purrr::map(c("mac","purp","lam","ymac","red","pter"), function(x) {
  westend.xmap_rast %>%
    filter(predictee==x,!is.na(rho))->out
  out <- c(x,out$predictor)
  out
})

names(westend.causal.vars)=c("mac","purp","lam","ymac","red","pter")

### NOT RUN: VERSION OF MODELS WHERE MULTIVARIATE S-MAPS EQUALS BEST EMBEDDING DIMENSION
# For each, take only the top n causal vars, where n is equal to the best embedding dimension from above
# If n > total number of significant variables from CCM, substitute lagged versions of the variable for dimensions
# westend.causal.vars <- purrr::map(c("mac","purp","lam","ymac","red","pter"),function(x){
#   # number of predictor variables (minus 1 because we use the species' own time series)
#   nvars <- westend.bestE[[x]]
#   westend.xmap_rast %>%
#     select(predictee,predictor,rho)%>%
#     filter(predictee==x)%>%
#     top_n(nvars-1,wt=rho) -> out
#   out <- c(x,out$predictor)
#   if(length(out)<nvars) {
#     ndiff <- nvars-length(out)
#     out <- c(out,paste0(x,1:ndiff))
#   }
#   out
# })
# names(westend.causal.vars) <- c("mac","purp","lam","ymac","red","pter")
# Have to add lagged variables for ymac
# westend <- westend %>% group_by(site) %>% mutate(ymac1=lag(ymac,1)) %>% ungroup()

```

***

### Multivariate Attractors

The multivariate models reconstruct attractors for each species based on their causally linked variables from CCM. A partial visualization of one of those attractors in state space might look something like this:

```{r 3d plot,fig.height=4,fig.width=4,dpi=300}
require(plot3D)

x <- westend$lam
y <- westend$mac
z <- westend$purp

seg.start <- as.numeric(westend.segs[1,1])
seg.end <- as.numeric(westend.segs[1,2])

#smooth
t <- 1:length(seg.start:seg.end)
tt<-seq(1,length(seg.start:seg.end),len=500)

xsmooth<-splinefun(t, x[seg.start:seg.end])(tt)
ysmooth<-splinefun(t, y[seg.start:seg.end])(tt)
zsmooth<-splinefun(t, z[seg.start:seg.end])(tt)

xtemp <- x[seg.start:seg.end]
ytemp <- y[seg.start:seg.end]
ztemp <- z[seg.start:seg.end]

# plot
op<-par()
par(mai=c(0.1,0.1,0.1,0.1))
scatter3D(xsmooth,ysmooth,zsmooth, col="gray30",
          type="l",phi=40,theta=55,bty="b",xlab = "Laminaria", ylab = "Macrocystis", zlab = "Purple Urchin")
points3D(xtemp,ytemp,ztemp,col="black",pch=19,cex=0.5,add=T)

for(i in 2:5) {
  seg.start <- as.numeric(westend.segs[i,1])
  seg.end <- as.numeric(westend.segs[i,2])
  
  #smooth
  t <- 1:length(seg.start:seg.end)
  tt<-seq(1,length(seg.start:seg.end),len=500)
  xsmooth<-splinefun(t, x[seg.start:seg.end])(tt)
  ysmooth<-splinefun(t, y[seg.start:seg.end])(tt)
  zsmooth<-splinefun(t, z[seg.start:seg.end])(tt)
  
  xtemp <- x[seg.start:seg.end]
  ytemp <- y[seg.start:seg.end]
  ztemp <- z[seg.start:seg.end]
  
  # plot
  
  scatter3D(xsmooth,ysmooth,zsmooth, col="gray30",
            type="l",bty="b",add=T)
  points3D(xtemp,ytemp,ztemp,col="black",pch=19,cex=0.5,add=T)
}

scatter3D(x[46],y[46],z[46],col="red",pch=19,cex=2,add=T)

#manually find nearest neighbors to point 46
temp <- westend %>% select(lam,mac,purp) %>% slice(1:315) %>% mutate(id=row_number()) %>%
  filter(!is.na(lam))
tempnn <-nn2(temp[,1:3],k=4)$nn.idx %>% as.data.frame()
names(tempnn) <- c("nn1","nn2","nn3","nn4")
temp <- bind_cols(temp,tempnn)

scatter3D(x[109],y[109],z[109],col="darkgreen",pch=19,cex=2,add=T)
scatter3D(x[235],y[235],z[235],col="darkgreen",pch=19,cex=2,add=T)
scatter3D(x[169],y[169],z[169],col="darkgreen",pch=19,cex=2,add=T)

scatter3D(x[110],y[110],z[110],col="blue",pch=19,cex=2,add=T)
scatter3D(x[236],y[236],z[236],col="blue",pch=19,cex=2,add=T)
scatter3D(x[170],y[170],z[170],col="blue",pch=19,cex=2,add=T)
# 
# dev.copy(png,"plots/multi_attractor.png",width=700,height=700,res=96)

par(op)
rm(xsmooth,ysmooth,zsmooth,xtemp,ytemp,ztemp,t,tt,seg.start,seg.end,x,y,z,temp)
```

Here we can see some apparent "states" of the *Laminaria*-*Macrocystis*-urchin dynamic system. There is some evidence here of three orthogonal states: when density of one of the species is well above its mean, the density of the other two are low. 

It is important to note, however, that this attractor is not entirely "unfolded" in just these three dimensions-- this is not quite a smooth multivariate attractor. This makes sense according to our previous CCM analysis. Although we cannot display more than three dimensions visually, our models in the previous step above suggest that any of these variables require more than three dimensions (embedding dimensions from Step 2) to make the most accurate predictions.

However, as a further illustration of how predictions are made in EDM, consider the red dot in the figure above. If we are trying to predict the future trajectory for this ecosystem state (i.e., the combination, in this case, of the densities of the three species), we use multivariate projection. For simplex projection, we would find the closest neighbors in state-space to the point of interest (the green dots), and then our prediction is a weighted average of those neighbors projected forward one point in time (the blue dots). The average is weighted by the Euclidean distance of the green dots from the red dot. S-map forecasting works in a similar manner, except it uses all the points on the attractor (not just the nearest neighbors; see description of S-maps in Step 2).

***

### Dynamic Species Interaction Models

```{r general smap model fxn, include=F}
# Generalized function to build a multivariate S-map model. Function takes the data, a data frame of the segments (i.e., the denoting the different within-site swaths denoting breaks in the time series), the target species (the one for which we are building a model), and a character vector of the other, causal variables. The function returns the fitted model and the coefficients (i.e., the species interaction partials), the model statistics, and a box plot of the interactions coefficients for that species across all the data.

smap_multi <- function(sitedat,sitesegs,species,causalvars) {
  
  full.mod <- block_lnlp(sitedat,lib=as.matrix(sitesegs),pred=as.matrix(sitesegs),columns=causalvars,target_column = species,theta = c(0, 1e-04, 3e-04, 0.001,0.003, 0.01, 0.1, 0.5, 1, 2, 4, 6,8), num_neighbors=0,method="s-map",silent=T)

  opttheta <- full.mod$theta[full.mod$rho==max(full.mod$rho)]
  
  best.mod <- block_lnlp(sitedat,lib=as.matrix(sitesegs),pred=as.matrix(sitesegs),columns=causalvars,target_column = species,theta = opttheta, num_neighbors=0,method="s-map",save_smap_coefficients=T,silent=T)
  
  # gather and organize model output
  t <- best.mod$model_output[[1]]$time
  
  coeff.names <- c(causalvars,"const")
  # Save interaction coefficients
  coeffs <- best.mod$smap_coefficients[[1]]
  names(coeffs) <- coeff.names
  
  # # Model output-- time, observations, predictions. match time indicator with observations (one period ahead)
  coeffs <- coeffs %>% mutate(time=t)%>%complete(time=full_seq(x=c(1,630),1)) %>% mutate(period=rep(1:63,10))
  
  # Save coefficient variances (sensu Deyle 2016; we have a nxn variance-covariance matrix for each estimated point, where n is the total number of causal variables for whom coefficients are estimated, plus the constant term)
  # Variances for individual coefficients are the diagonals of each covariance matrix
  coeffs.variances <- best.mod$smap_coefficient_covariances[[1]] %>%
    purrr::map_dfr(function(x) {
      # if no estimate, no variance associated with it (NULL)
      if(is.null(x)) x <- matrix(NaN,nrow=length(coeff.names),ncol=length(coeff.names))
      # pull out diagonal elements, add variable names
      out <- t(diag(x)) %>% as.data.frame()
      names(out) <- coeff.names
      out
      })%>%
    
    # add period identifier and overall time stamp
    # mutate(time=t) %>% complete(time=full_seq(c(1,630),1)) %>% mutate(period=rep(1:63,10))
    mutate(time=t)%>%complete(time=full_seq(x=c(1,630),1)) %>% mutate(period=rep(1:63,10))
  
  # long form for plotting, including variance
  coeffs.long <- coeffs %>%
    gather(key=effect,value=value,-period,-time,na.rm=T) %>%
    left_join(namekey, by=c("effect"="short"))
  
  # long form variances
  coeffs.variances.long <- coeffs.variances %>%
    gather(key=effect,value=variance,-period,-time,na.rm=T) %>%
    left_join(namekey,by=c("effect"="short"))
  
  coeffs.long <- coeffs.long %>%
    left_join(coeffs.variances.long,by=c("time","period","effect","dataset","long","plotting")) %>%
    # add standard deviation and +/- 95% CI (1.96*SD)
    mutate(sd=sqrt(variance),upper=value+1.96*sd,lower=value-1.96*sd)
  
  # box plot of interactions
  sppname <- species
  int.box <- coeffs.long %>% filter(effect!='const')%>%
    ggplot(aes(x=plotting,y=value))+
    geom_boxplot() +
    geom_hline(yintercept=0,linetype=2,col="gray40")+
    xlab("Interacting Variable") +
    ylab("Coefficient") +
    ggtitle(paste("Interactive Effects on Dynamics of ",sppname))
  
  ## Outputs (to go in a list)

  outlist <- list(model=best.mod,coeffs=coeffs,coeffs.variances=coeffs.variances,coeffs.long= coeffs.long,plot=int.box)
  return(outlist)
}
```


```{r apply multivariate models, include=F,warnings=F}
# Apply to the West End data
westend.multi.mods <- purrr::map(list("mac","purp","lam","ymac","red","pter"),function(x) {
  smap_multi(westend,westend.segs,x,westend.causal.vars[[x]])
})
names(westend.multi.mods) <- c("mac","purp","lam","ymac","red","pter")
```

When we construct multivariate models for the six variables in the data based on their causal relationships, we get multivariate S-map models that perform well, displaying a high level of correlation between out-of-sample predictions and observed values, and relatively low mean absolute error (MAE).

```{r model perf,echo=F}
# collect model performance statistics
westend.model.perf <- tibble(Species=c("Macrocystis","Purple Urchin","Laminaria","Young Macrocystis","Red Urchin","Pterygophora"),
                             Predictors=purrr::map(westend.causal.vars,.f=function(x){
                               y=namekey$long[match(x,namekey$short)];paste(y,sep=",",collapse=", ")}),
                             Theta = map_dbl(westend.multi.mods,function(x) x$model$theta),
                             Rho = map_dbl(westend.multi.mods,function(x) x$model$rho),
                             MAE=map_dbl(westend.multi.mods,function(x) x$model$mae),
                             mod=c("mac","purp","lam","ymac","red","pter"))
westend.model.perf %>% select(-mod) %>% 
  kable("latex",col.names = c("Modeled Species","Predictors","$\\theta$","$\\rho$","MAE"),digits=3,escape=F) %>%
  kable_styling(full_width = F) %>%
  column_spec(1,bold=T)%>%
  column_spec(2, width = "30em")
```


```{r all model effects join, echo=F,warning=F}
# Join all coefficients
all.mod.coeffs.long <- purrr::map(names(westend.multi.mods),function(x){
  westend.multi.mods[[x]][["coeffs.long"]] %>% mutate(mod=x)
  }
  )%>%
  bind_rows() %>%
  mutate(mod_plotting_name = namekey$long[match(mod,namekey$short)])


# assign interaction types: competition, herbivory (effect of urchins on algae), consumption (effect of algae on urchin), or growth
algaes<-c("lam","mac","pter","ymac")
urchins <- c("red","purp")
combinations <- expand.grid(study_spp,study_spp) %>% 
  rename(mod=Var1,effect=Var2) %>%
  select(mod,effect)%>%
  mutate(type = case_when(
    mod ==   effect ~ "intraspecies",
    mod == "mac" & effect == "ymac" ~ "intraspecies",
    mod == "ymac" & effect == "mac" ~ "intraspecies",
    mod %in% algaes & effect %in% algaes ~ "algal competition",
    mod %in% urchins & effect %in% urchins ~ "urchin competition",
    mod %in% algaes & effect %in% urchins ~ "herbivory",
    mod %in% urchins & effect %in% algaes ~ "consumption",
    TRUE ~ "NA"
    ),
    type=factor(type,levels=c("algal competition","urchin competition","herbivory","consumption","intraspecies")),
    spp_type = case_when(
      mod %in% algaes ~ "algae",
      mod %in% urchins ~ "urchin",
      TRUE ~ "none"
    )
  ) %>%
  mutate_at(vars(mod,effect),as.character)

# add rho label for facet plotting
mod_rho_labels <- westend.model.perf %>%
  mutate(label1="rho==",Rho_round=round(Rho,2))%>%
  unite(label,label1,Rho_round,sep="",remove=F)%>%
  select(mod,label)

all.mod.coeffs.long %>%
  #add the type of interaction
  left_join(combinations,by=c("mod","effect"))%>%
  left_join(mod_rho_labels,by="mod") -> all.mod.coeffs.long
```

***

## 5. Results

### Multivariate Model Output: Species interactions

We can pull from the models every predicted interaction between species. These fitted interaction strengths are specifically the estimated effect of the density of one species on itself or another species, when forecasting one monitoring period (approximately six months) ahead. For example, each data point for *Pterygophora* in the *Macrocystis* model is the predicted effect of the current density of Pterygophora on the density of Macrocystis in the next monitoring period. Mathematically, each interaction measured is a partial derivative, or element of our locally calculated Jacobian matrices (the coefficients of our locally-weighted S-maps), estimating the effect of one species on another, $\delta N_{1}/\delta N_{2}$. The distributions of those interactions are shown for each separate species model in the figure below.

```{r boxplot of species interactions, echo=F,warning=F,message=F,fig.height=8,fig.width=7.5}
# boxplot of all species interactions
all.mod.coeffs.plot.box <- all.mod.coeffs.long %>%
  #filter for just species (no physical vars yet)
  filter(effect %in% study_spp) %>%
  #plot
  ggplot(aes(x=plotting,y=value,fill=type))+
  geom_boxplot(outlier.alpha=0.4,outlier.size=1,width=0.8,position = "identity")+
  stat_summary(fun.y=mean, colour="white", geom="point", 
               shape=17, size=2,show.legend = FALSE)+
  scale_fill_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  geom_hline(yintercept=0,linetype=2)+
  geom_text(aes(x=1.2,y=1.8,label=label),size=4, parse=T,check_overlap=TRUE,show.legend = FALSE)+
  ylim(-2,2)+
  coord_flip()+
  labs(y="Estimated Interaction Coefficient",x="Interacting Species")+
  facet_grid(mod_plotting_name~.,scales="free",space="free")

all.mod.coeffs.plot.box
# ggsave("plots/all_spp_coeffs.png",plot=all.mod.coeffs.plot.box,height=8,width=7.5)
```

These are box-and-whisker plots of estimated species interaction strengths from S-map models for the five focal species (panels top to bottom): *Macrocystis* adults, *Macrocystis* juveniles, *Pterygophora*, *Laminaria*, purple urchin, and red urchin. Each colored box represents the distribution of all estimated interaction coefficients (x-axis) of an interacting or forcing species (left y-axis) on a modeled species (right y-axis) across all data for a given model (white triangles: mean; vertical lines: median; box: interquartile range; whiskers extend to data point at most $1.5*IQR$ from the box). Correlation coefficient between predictions and observations denoted for each model. Color denotes hypothesized interaction type, including interspecific competition (between algae species or between urchin species), herbivory (urchin effect on algae), consumption (algae effect on urchins), and intraspecies interaction (the estimated interaction of a species with itself). Abbreviations: S. pur, *Strongylocentrotus purpuratus*; P cal., *Pterygophora californica*; M. pyr, *Macrocystis pyrifera*; M. fra, *Mesocentrotus franciscanus*; L. far, *Laminaria farlowii*.

It is clear from the boxplots that fitted intra- and interspecific interactions display evidence of positive, negative, and neutral interactions. Over the range of conditions in the time series, each species variable with the exception of young *Macrocystis* has positive intraspecific effects; that is, each speciesâ density has a positive estimated effect on itself, a combination of survivorship and new recruitment. Relative to the magnitude of other interactions, this intraspecific effect is strongest in the two urchin species.

The interactions of the urchin and algal species show evidence of herbivory (purple boxes). Both red and purple urchin density have predominantly negative effect on adult and juvenile *Macrocystis*, *Laminaria*, and *Pterygophora*, effects that were consistent with our hypotheses. However, the converse effects of algal density on urchin density (green boxes) are generally small, and not consistently positive.

Few strong and consistent competitive interactions (red and orange boxes for urchin and algal competition, respectively) are observed in model estimates. Estimates of the interaction between the two urchin species are small and near zero. The interactions are small relative to other forcing factors in the urchin models, and are occasionally positive (apparent mutualism). Among the algal species, the clearest negative competitive effect is that of *Pterygophora* on adult *Macrocystis* (top panel). Other interactions are not always negative (competitive), and contrary to expectations, positive values were estimated for many interactions. *Pterygophora* has only intermittent negative effects on young *Macrocystis*, and *Pterygophora* and *Laminaria* display an apparent mutualism. Perhaps most surprisingly, *Macrocystis* does not display a consistent negative effect on *Pterygophora* or *Laminaria*, contrary to our hypothesis of *Macrocystis* competitive dominance [@Dayton1999].

***

### Multivariate Model Output: Physical Forcing

We can also investigate the effects of the physical forcing variables on the biological dynamics in a similar plot:


```{r phys coeffs,echo=F,message=F,warning=F,fig.height=8,fig.width=8}
# with boxplot
all.phys.coeffs.plot <- all.mod.coeffs.long %>%
  filter(effect %in% phys.vars)%>%
  mutate(label = case_when(
    mod == "mac" ~ "Macrocystis >1m",
    mod == "ymac" ~ "Macrocystis <1m",
    mod == "lam" ~ "Laminaria",
    mod == "pter" ~ "Pterygophora",
    mod == "red" ~ "Red urchin",
    mod == "purp" ~ "Purple urchin")
  ) %>%
  ggplot(aes(effect,value))+
  scale_x_discrete(labels=c(
    "mei"="MEI",
    "npgo"="NPGO",
    "pdo"="PDO",
    "waves"="SWH",
    "sst"="SST")
    )+
  geom_boxplot(fill="dodgerblue2",outlier.alpha=0.4,position = "identity")+
  stat_summary(fun.y=mean, colour="white", geom="point", 
               shape=17, size=2,show.legend = FALSE)+
  geom_hline(yintercept=0,linetype=2)+
  ylim(-2,2)+
  coord_flip()+
  labs(y="Estimated Interaction Coefficient",x="Physical Forcing")+
  facet_grid(mod_plotting_name~.)+
  geom_text(aes(x=1.5,y=2,label=label),hjust=1,family="Rockwell",fontface="italic",check_overlap = TRUE,size=4,show.legend = FALSE)+
  theme(strip.background = element_blank(),
        strip.text = element_blank())
all.phys.coeffs.plot
# ggsave("plots/phys_coeffs.png",plot=all.phys.coeffs.plot)
```

In this figure, each box represents the distribution of estimated effect of a physical driver (left y-axis) on the modeled species across all data for a given model. Empty rows indicate physical variables that were not included in specific species models because of a lack of a causal signal from our CCM. Abbreviations: SWH, significant wave height; SST, sea surface temperature; PDO, Pacific Decadal Oscillation; NPGO, North Pacific Gyre Oscillation; MEI, Multivariate ENSO Index.

Physical forcing variables affect the dynamics of all species in the study, to varying degrees. *Macrocystis* is the only species in the analysis that displays a significant cross-mapping signal (significant causal forcing) with all five included physical variables. The negative effect of SWH on adult *Macrocystis*, and the positive effect of the NPGO, are consistent with our expectations [@Bell2015]. However, the PDO index has a positive effect on *Macrocystis*, contrary to expectation because in general, positive values of the PDO are associated with warmer SST and nutrient-poor conditions in the northeast Pacific. *Macrocystis* recruits, on the other hand, are positively affected by the MEI, SWH, and SST, and negatively affected by the PDO and NPGO. Together, the effects of physical forcing on *Macrocystis* suggest that conditions that are poor for survivorship of adults (higher SST, less nutrient availability, greater disturbance) may produce favorable conditions for recruitment of new sporophytes.

The physical variables are more influential drivers of *Macrocystis* than *Pterygophora* or *Laminaria* dynamics. No physical variable was causally linked to *Laminaria* density. Conversely, although the PDO, NPGO, SWH and SST were identified as causal variables for *Pterygophora* density, the magnitudes of their effects are small and inconsistent.

The effects of physical forcing are not limited to the algal species, although the magnitude of physical forcing effects on red urchins are small, especially compared to the effect of their own density (the intraspecific effect). For the purple urchin, the PDO, NPGO, and MEI all have negative but variable effects. For red urchin, the effects of SWH and SST are small and negative, while the effect of the NPGO is slightly positive.

***

### Physical Forcing Effect on Interactions

A major observation from the multivariate models is that many interactions between species and between species and their environments can be variable (positive or negative, depending on conditions). For the algal species especially, the combination of variable interspecific interaction strengths and occasionally strong environmental forcing effects suggests that the strength of species interactions may be driven by environmental context.

In order to observe this, we remove physical forcings and re-run the multivariate models with just the species interactions, and then look at the resulting trends through the lens of various physical forcing (to remove endogeneity). We will investigate the effect of environmental variables on interaction strength for the different interaction types (herbivory, competition, and intraspecies effects).

```{r model spp_only,warning=F,fig.height=8,fig.width=7.5}
# remove physical variables from predictors then run models
causal.vars.spp <- purrr::map(westend.causal.vars,function(x) setdiff(x,phys.vars))
multi.mods.spp.only <- purrr::map(list("mac","purp","lam","ymac","red","pter"),function(x) {
  smap_multi(westend,westend.segs,x,causal.vars.spp[[x]])
})
names(multi.mods.spp.only) <- c("mac","purp","lam","ymac","red","pter")

# collect model performance statistics
spp.only.model.perf <- tibble(Species=c("Macrocystis","Purple Urchin","Laminaria","Young Macrocystis","Red Urchin","Pterygophora"),
                             Predictors=purrr::map(causal.vars.spp,.f=function(x){
                               y=namekey$long[match(x,namekey$short)];paste(y,sep=",",collapse=", ")}),
                             Rho = map_dbl(multi.mods.spp.only,function(x) x$model$rho),
                             MAE=map_dbl(multi.mods.spp.only,function(x) x$model$mae),
                             mod=c("mac","purp","lam","ymac","red","pter"))
spp.only.model.perf %>% select(-mod) %>% 
  kable("latex",col.names = c("Modeled Species","Predictors","$\\rho$","MAE"),digits=3,escape=F) %>%
  kable_styling(full_width = F) %>%
  column_spec(1,bold=T)%>%
  column_spec(2, width = "30em")

# Join all coefficients
spp.only.mod.coeffs <- purrr::map(names(multi.mods.spp.only),function(x){
  multi.mods.spp.only[[x]][["coeffs.long"]] %>% mutate(mod=x)
  }
  )%>%
  bind_rows() %>%
  mutate(mod_plotting_name = namekey$long[match(mod,namekey$short)])


# assign interaction types: competition, herbivory (effect of urchins on algae), consumption (effect of algae on urchin), or growth
algaes<-c("lam","mac","pter","ymac")
urchins <- c("red","purp")
combinations <- expand.grid(study_spp,study_spp) %>% 
  rename(mod=Var1,effect=Var2) %>%
  select(mod,effect)%>%
  mutate(type = case_when(
    mod ==   effect ~ "intraspecies",
    mod == "mac" & effect == "ymac" ~ "intraspecies",
    mod == "ymac" & effect == "mac" ~ "intraspecies",
    mod %in% algaes & effect %in% algaes ~ "algal competition",
    mod %in% urchins & effect %in% urchins ~ "urchin competition",
    mod %in% algaes & effect %in% urchins ~ "herbivory",
    mod %in% urchins & effect %in% algaes ~ "consumption",
    TRUE ~ "NA"
    ),
    type=factor(type,levels=c("algal competition","urchin competition","herbivory","consumption","intraspecies")),
    spp_type = case_when(
      mod %in% algaes ~ "algae",
      mod %in% urchins ~ "urchin",
      TRUE ~ "none"
    )
  ) %>%
  mutate_at(vars(mod,effect),as.character)

# add rho label for facet plotting
mod_rho_labels <- spp.only.model.perf %>%
  mutate(label1="rho==",Rho_round=round(Rho,2))%>%
  unite(label,label1,Rho_round,sep="",remove=F)%>%
  select(mod,label)

spp.only.mod.coeffs %>%
  #add the type of interaction
  left_join(combinations,by=c("mod","effect"))%>%
  left_join(mod_rho_labels,by="mod") -> spp.only.mod.coeffs

# boxplot of all species interactions
spp.only.mod.coeffs.plot.box <- spp.only.mod.coeffs %>%
   filter(effect %in% study_spp) %>%
  #plot
  ggplot(aes(x=plotting,y=value,fill=type))+
  geom_boxplot(outlier.alpha=0.4,outlier.size=1,width=0.8,position = "identity")+
  stat_summary(fun.y=mean, colour="white", geom="point", 
               shape=17, size=2,show.legend = FALSE)+
  scale_fill_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  geom_hline(yintercept=0,linetype=2)+
  geom_text(aes(x=1.2,y=1.8,label=label),size=4, parse=T,check_overlap=TRUE,show.legend = FALSE)+
  ylim(-2,2)+
  coord_flip()+
  labs(y="Estimated Interaction Coefficient",x="Interacting Species")+
  facet_grid(mod_plotting_name~.,scales="free_y",space="free")

spp.only.mod.coeffs.plot.box
# ggsave("plots/spp_only_mods_coeffs.png",plot=spp.only.mod.coeffs.plot.box,height=8,width=7.5)
```

```{r mean interactions, fig.height=8,fig.width=7.5}
## Mean interactions vs. physical conditions
# join all original density variables to interaction data

spp.only.coeffs.with.phys<- westend %>%
  select(one_of(c(phys.vars,"period"))) %>%
  distinct() %>%
  right_join(filter(spp.only.mod.coeffs,!is.na(type)),by="period")%>%
  gather("external_forcing","ext_value",one_of(phys.vars))

```

***

### Effects on Individual Species

With 5%/95% quantile regression. Columns/x-axis indicates the normalized level of a physical stressor, while rows and y-axis denote the type of species interaction (corresponding to the colors in the boxplots above).

```{r individual_effects,fig.width=7}
phys_effects_on_interactions <- purrr::map(as.list(study_spp),function(spp) {
  quants <- c(0.05,0.5,0.95)
  plot_title <- namekey$long[match(spp,namekey$short)]
  spp.only.coeffs.with.phys %>%
  filter(!is.na(type),mod==spp)%>%
  ggplot(aes(ext_value,value,col=factor(effect,levels=c("mac","ymac","pter","lam","purp","red"))))+
    # geom_linerange(aes(ymin=lower,ymax=upper),col='gray60')+
    geom_point(col='gray60',alpha=0.6)+
    geom_hline(yintercept = 0,linetype=2)+
    geom_quantile(quantiles=quants,lineend = "round",size=1,formula=y~x)+
    scale_color_manual(values=c('mac'="navyblue",'ymac'="gray30",'pter'="darkgreen",'lam'="darkcyan",'purp'="mediumpurple4",'red'="darkred"),name="effect")+
    labs(title=paste("Physical forcing effect on interactions with",plot_title),x="Normalized Index Value",y="Interaction Strength")+
    facet_grid(type~external_forcing,scales = "free_y")+
    theme(strip.text=element_text(size=8),
          legend.text = element_text(size=12),
          legend.position="right",
          legend.margin=margin(t = -0.5, unit='line'),
          plot.margin=unit(c(0.5, 0.5, 0.5, 0.5), units="line")
        )
})
# ggsave("plots/phys_effects_red.png",plot=phys_effects_on_interactions[[1]])
# ggsave("plots/phys_effects_purp.png",plot=phys_effects_on_interactions[[2]])
# ggsave("plots/phys_effects_lam.png",plot=phys_effects_on_interactions[[3]])
# ggsave("plots/phys_effects_pter.png",plot=phys_effects_on_interactions[[4]])
# ggsave("plots/phys_effects_mac.png",plot=phys_effects_on_interactions[[5]])
# ggsave("plots/phys_effects_ymac.png",plot=phys_effects_on_interactions[[6]])

phys_effects_on_interactions[[1]]
phys_effects_on_interactions[[2]]
phys_effects_on_interactions[[3]]
phys_effects_on_interactions[[4]]
phys_effects_on_interactions[[5]]
phys_effects_on_interactions[[6]]
```

Here are some notable effects/trends for each species:

* *Mesocentrotus franciscanus*
    + chance of competition with *Strongylocentrotus purpuratus* seems reduced under higher physical (wave) stress
    + the same (reduced competition) is marginally true for nutrient-rich conditions (higher NPGO);and the opposite for nutrient- stressed conditions (higher MEI, PDO indices)
    
* *Strongylocentrotus purpuratus*
    + "urchin competition" seems like a misnomer for this species; the effect of *Mesocentrotus franciscanus* on *S. purpuratus* is primarily positive across a range of physical conditions. The effect is dampened somewhat under increased wave disturbance
    + Effect of *S. purpuratus* on itself ("population growth rate" in a way) is affected by oceanographic forcing: it is slightly increased under increased NPGO values and with increased disturbance, and slightly decreased under elevated MEI, PDO, and SST. 
    
* *Laminaria farlowii*
    + Important to note that no physical variables in this analysis showed a causal signal for *Laminaria* from CCM
    + as far as competition goes, most large, negative interactions are associated with juvenile *Macrocystis*, likely as an indicator of impending successional processes (i.e., the juvenile *Macrocystis* growing into large *Macrocystis*). This expected negative effect is reduced under elevated PDO, disturbance, and SST, which makes sense: these are conditions that classically inhibit *Macrocystis* dominance[@Reed2011; @Cavanaugh2011; @Bell2015,@Young2015].
    + In general, *M franciscanus* has a more negative effect on *Laminaria* than does *S. purpuratus*, and that effect is not overly sensitive to physical conditions, although the negative effect is dampened somewhat under elevated disturbance
    + Physical conditions seem to strongly influence intraspecies *Laminaria* effects: the positive effect of *Laminaria* on its own density is reduced under elevated MEI, PDO, and SST, and increased under elevated NPGO and disturbance.

* *Pterygophora californica*
    + Algal effects: *Macrocystis* has a near-zero mean effect on *Pterygophora*. However, the quantile regression suggests that *Macrocystis* can have a strong negative effect on *Pterygophora* at lower relative levels of nutrient and temperature stress (high NPGO, low MEI and PDO, lower SST), and potentially after disturbance.
    + Herbivory effects on *Pterygophora* vary with physical environment. *M. franciscanus* and *S. purpuratus* have similar mean effects on *Pterygophora*, and that herbivory is sensitive to physical conditions. The effect of herbivory is strongest under elevated disturbance and NPGO, and diminished under elevated MEI, PDO, and SST.
    + Little variation in the intraspecies effect of *Pterygophora* along physical gradients.

* *Macrocystis pyrifera*
    + Because we have two variables measuring the density of different *Macrocystis* life stages, we can parse out the relative effects of physical conditions on adult vs. juvenile giant kelp.
    + Environmental stress seems to strengthen the interactions between *Laminaria* and *Pterygophora* and *Macrocystis* recruits. Under conditions of elevated MEI, SST, or PDO, or decreased NPGO, the positive effect of *Pterygophora* and the negative effect of *Laminaria* on *Macrocystis* sporophytes are both enhanced. Similar is true for the adult *Macrocystis*: interactions between the giant kelp and the other algae species are elevated under nutrient- or temperature-stressed conditions. Increased wave height (physical disturbance) does not seem to have a large effect on the effect of *Laminaria* and *Pterygophora* on *Macrocystis*
    + The effect of purple urchin on both *Macrocystis* adult and juvenile density is stronger than the red urchin effect, and more variable with changing conditions. Purple urchin herbivory as a negative influence on *Macrocystis* is enhanced with elevated disturbance, MEI, and PDO, and slightly reduced with an increase in the NPGO.
    + The strengths of intraspecies effects (effects of *Macrocystis* adults on juveniles and vice versa) are also influenced by physical conditions, but perhaps in a different way than might be expected. The positive effect of juvenile *Macrocystis* on adult *Macrocystis* seems to be **enhanced** under nutrient-stressed conditions and higher temperatures, and reduced with greater nutrient availability and increased disturbance.

### Summarized effects of different physical conditions

* **Large-scale oceanographic oscillations: NPGO, MEI, and PDO**
    + Higher nutrient availability often associated with higher values of the NPGO, and lower values of the MEI and PDO.
    + High nutrient availability leads to higher urchin growth rates and reduced competition between urchin species. *Laminaria* and *Pterygophora* intraspecific effects are enhanced, while the *Macrocystis* intraspecies effect is reduced. The negative effect of herbivory is strengthened for *Pterygophora*, but reduced for *Macrocystis*. The ability of *Pterygophora* and *Laminaria* to compete with *Macrocystis* is reduced under greater nutrient availability, as evidenced by a decrease in interaction strength between the two understory species and the giant kelp, as well as an increase in the positive association of the two with each other, likely as a mutual defense against *Macrocystis* dominance.
    + The opposite of the above effects are true for nutrient-scarce conditions. High values of the MEI and PDO, and low values of the NPGO, are associated with reduced urchin growth and marginally increased urchin competition. The negative effect of herbivory is reduced for *Pterygophora*, but exacerbated for *Macrocystis*. The understory species are favored in algal competition, in that their negative effects on *Macrocystis* are strengthened, and the converse effects of *Macrocystis* on the understory are reduced. Interestingly, *Pterygophora* seems beneficial for *Macrocystis* recruitment under nutrient-stressed conditions, while *Laminaria* is inhibitory. The *Laminaria* intraspecies effect is reduced, while the intraspecies *Macrocystis* effect is enhanced.
    + The qualitative story to be told here is that under nutrient-poor conditions, a *Pterygophora* state is favored in a relative sense over a *Macrocystis* dominant state. Under nutrient-stressed conditions, *Pterygophora* is more resistant to herbivory, and more inhibitory to adult *Macrocystis*. However, *Pterygophora* is beneficial for *Macrocystis* recruitment, while *Laminaria* inhibits *Macrocystis* recruitment under nutrient stressed conditions. When conditions are "better" (more nutrients), *Macrocystis* gains. It becomes more able to withstand herbivory, less sensitive to *Pterygophora* or *Laminaria* presence, and more inhibitory to *Pterygophora*.
    
* **Temperature**
    + Elevated SST has similar effects to nutrient stress (elevated MEI and PDO, and reduced NPGO), which makes sense: In Southern California, elevated SST is associated with reduced nutrient availability[@Zimmerman1984,@Bell2015]. Similar effects as described above for nutrient stress (at least as measured by the large oceanographic indices) hold for elevated temperature. This suggests both that this type of effect manifests at multiple temporal scales, and that the combination of elevated temperature and stressful nutrient regimes could have compounding effects on species interactions and ecosystem dynamics.
    
* **Physical disturbance**
    + Higher max wave heights was our proxy for physical stress/disturbance.
    + Higher physical disturbance levels results in reduced interaction strength between the urchin species.
    + *Pterygophora* and *Macrocystis* are both subject to a greater negative effect of herbivory under increased disturbance.
    + *Laminaria* benefits as well. The negative effects of herbivory and algal competition are reduced with increased disturbance, and its intraspecies effect is strengthened.
    + The positive effect of juvenile on adult *Macrocystis* is reduced with increased physical stress.
    
### Example: Effect of Macrocystis on Pterygophora

```{r mac pter,fig.width=6,fig.height=6}
mac_effect_on_pter <-spp.only.coeffs.with.phys %>%
  ungroup()%>%
  filter(mod=="pter",effect=="mac")%>%
  mutate(phys_high_low=case_when(
    ext_value > 1 ~ "high",
    ext_value < -1 ~ "low")) %>%
  filter(!is.na(phys_high_low))%>%
  left_join(select(westend,period,one_of(phys.vars)),by="period")%>%
  group_by(type,external_forcing,phys_high_low)%>%
  mutate(mean_int=mean(value,na.rm=T))%>%
  distinct()%>%
  ungroup()

# physical forcings labeller
phys.labeller <- c(
  mei= "MEI",
  npgo= "NPGO",
  pdo= "PDO",
  sst="SST",
  waves="SWH"
)

mac_effect_on_pter_plot <-mac_effect_on_pter %>%
ggplot(aes(value,..density..,fill=phys_high_low))+
  geom_density(col=NA,alpha=0.6)+
  geom_vline(xintercept=0,linetype=2)+
  geom_vline(aes(xintercept=mean_int,color=phys_high_low),size=1.5)+
  scale_fill_manual(values=c("darkorange","dodgerblue4"),name="Physical\nForcing Value",labels=c("high","low"))+
  scale_color_manual(values=c("darkorange","dodgerblue4"))+
  guides(color="none")+
  labs(x="Effect of Macrocystis on Pterygophora",y="Probability Density")+
  facet_grid(rows=vars(external_forcing),labeller=labeller(external_forcing=phys.labeller))+
  theme(strip.text=element_text(size=10))

# ggsave("plots/mac_effect_on_pter_phys.png",plot=mac_effect_on_pter_plot,h=6,w=6,dpi=500)
# ggsave("plots/mac_effect_on_pter_phys.pdf",plot=mac_effect_on_pter_plot,h=6,w=6)
mac_effect_on_pter_plot
```

```{r pter effect ymac,fig.height=6,fig.width=6}
pter_effect_ymac <-spp.only.coeffs.with.phys %>%
  ungroup()%>%
  filter(mod=="ymac",effect=="pter")%>%
  mutate(phys_high_low=case_when(
    ext_value > 1 ~ "high",
    ext_value < -1 ~ "low")) %>%
  filter(!is.na(phys_high_low))%>%
  left_join(select(westend,period,one_of(phys.vars)),by="period")%>%
  group_by(type,external_forcing,phys_high_low)%>%
  mutate(mean_int=mean(value,na.rm=T))%>%
  distinct()%>%
  ungroup()

# physical forcings labeller
phys.labeller <- c(
  mei= "MEI",
  npgo= "NPGO",
  pdo= "PDO",
  sst="SST",
  waves="SWH"
)

pter_effect_ymac_plot <-pter_effect_ymac %>%
ggplot(aes(value,..density..,fill=phys_high_low))+
  geom_density(col=NA,alpha=0.6)+
  geom_vline(xintercept=0,linetype=2)+
  geom_vline(aes(xintercept=mean_int,color=phys_high_low),size=1.5)+
  scale_fill_manual(values=c("darkorange","dodgerblue4"),name="Physical\nForcing Value",labels=c("high","low"))+
  scale_color_manual(values=c("darkorange","dodgerblue4"))+
  guides(color="none")+
  labs(x="Effect of Pterygophora on Macrocystis Recruits",y="Probability Density")+
  facet_grid(rows=vars(external_forcing),labeller=labeller(external_forcing=phys.labeller))+
  theme(strip.text=element_text(size=10))

# ggsave("plots/pter_effect_ymac_phys.png",plot=pter_effect_ymac_plot,h=6,w=6,dpi=500)
# ggsave("plots/pter_effect_ymac_phys.pdf",plot=pter_effect_ymac_plot,h=6,w=6)
pter_effect_ymac_plot
```

### Distribution of interaction strengths by type

```{r interactions density plot by type,fig.height=6,fig.width=6}
# Density plot
require(png)
a1 <- readPNG(here::here("plots","icons","macrocystis-transparent.png")) %>% rasterGrob()
interaction_distribution_by_type <- spp.only.mod.coeffs %>%
  filter(!is.na(type),type != "intraspecies")%>%
  group_by(type) %>%
  mutate(mean_int=mean(value,na.rm=T))%>%
  ungroup()%>%
  ggplot(aes(value,type,fill=type))+
  geom_density_ridges(alpha=0.8,scale=1.4)+
  # stat_density_ridges(geom="density_ridges_gradient",calc_ecdf='true',quantiles=4,alpha=0.8,scale=1)+
  # scale_fill_viridis_d(name="quantiles",alpha=0.8)+
  geom_vline(xintercept=0,linetype=2)+
  # geom_vline(aes(xintercept=mean_int,color=type))+
  scale_fill_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  scale_color_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  guides(fill=F,color=F)+
  xlim(-1.5,1.5)+
  labs(x="Interaction strength",y="Probability density")+
  annotation_custom(a1,ymin=2,ymax=3,xmin=-1,xmax=-0.5)+
  # geom_text(aes(x=-1.5,y=0.5,label=type),hjust="inward",family="Rockwell",fontface="italic",check_overlap = TRUE,size=4,show.legend = FALSE)+
  # facet_grid(rows=vars(type))+
  theme(strip.text = element_blank())

interaction_distribution_by_type
# ggsave("plots/int_dist_by_type_density.png",plot=interaction_distribution_by_type,h=6,w=6,dpi=500)
# ggsave("plots/int_dist_by_type_density.pdf",plot=interaction_distribution_by_type,h=6,w=6)
```

```{r ints dist by type and phys}
int_dist_by_type_phys <- spp.only.coeffs.with.phys %>%
  ungroup()%>%
  mutate(phys_high_low=case_when(
    ext_value > 1 ~ "high",
    ext_value < -1 ~ "low")) %>%
  left_join(select(westend,period,one_of(phys.vars)),by="period")%>%
  group_by(type,external_forcing,phys_high_low)%>%
  mutate(mean_int=mean(value,na.rm=T))%>%
  distinct()%>%
  ungroup()

int_dist_by_type_phys_plots <- purrr::map(phys.vars,function(x) {
  int_dist_by_type_phys %>%
    filter(external_forcing==x,!is.na(phys_high_low))%>%
    ggplot(aes(value,..density..,fill=phys_high_low,col=phys_high_low))+
    geom_density(alpha=0.6,col=NA)+
    geom_vline(xintercept=0,linetype=2)+
    geom_vline(aes(xintercept=mean_int,col=phys_high_low))+
    xlim(-2,2)+
    scale_fill_manual(values=c("red","blue"),name=paste0(x,"\nLevel"),labels=c("high (> 1)","low (< 1)"))+
    scale_color_manual(values=c('red','blue'))+
    guides(color="none")+
    geom_text(aes(x=-2,y=0.5,label=type),col="black",hjust="inward",family="Rockwell",fontface="italic",check_overlap = TRUE,size=4,show.legend = FALSE)+
    labs(x="Interaction strength",y="Kernel density")+
    facet_grid(rows=vars(type))+
    theme(strip.text=element_blank())
  })
names(int_dist_by_type_phys_plots) <- phys.vars
int_dist_by_type_phys_plots$mei
int_dist_by_type_phys_plots$sst
int_dist_by_type_phys_plots$pdo
int_dist_by_type_phys_plots$waves
int_dist_by_type_phys_plots$npgo

```

### Mean vs. variance in interactions

```{r mean vs variance}
int_mean_sd <-spp.only.mod.coeffs %>%
  filter(!is.na(type))%>%
  mutate(neutral=ifelse(lower<0 & upper>0,1,0))%>%
  group_by(mod,effect,type) %>%
  summarise(median_int=median(value,na.rm=T),mean_int=mean(value,na.rm=T),abs_mean=abs(mean_int),sd_int=sd(value,na.rm=T),n=n(),
            cv_int=sd_int/abs_mean*100,upper=quantile(value,0.975),lower=quantile(value,0.025),
            perc_neutral=sum(neutral)/n()*100)%>%
  ungroup()

# Mean interaction strength by interaction type
spp.only.mod.coeffs %>%
  filter(!is.na(type))%>%
  mutate(neutral=ifelse(lower<0 & upper>0,1,0))%>%
  filter(mod != "ymac",effect != 'ymac')%>%
  group_by(type) %>%
  summarise(mean_int=mean(value,na.rm=T),abs_mean=abs(mean_int),n=n(),upper=quantile(value,0.975),lower=quantile(value,0.025))%>%
  ungroup()%>%
  ggplot(aes(type,mean_int))+
  geom_col()+
  # geom_errorbar(aes(ymax=upper,ymin=lower),position='dodge',width=0.2)+
  labs(x='Interaction Type',y='Interaction Strength')

# Median interaction strength by interaction type
spp.only.mod.coeffs %>%
  filter(!is.na(type))%>%
  mutate(neutral=ifelse(lower<0 & upper>0,1,0))%>%
  filter(mod != "ymac",effect != 'ymac')%>%
  group_by(type) %>%
  summarise(mean_int=mean(value,na.rm=T),abs_mean=abs(mean_int),median_int=median(value,na.rm=T),n=n(),upper=quantile(value,0.975),lower=quantile(value,0.025))%>%
  ungroup()%>%
  ggplot(aes(type,median_int))+
  geom_col(fill="gray60")+
  geom_point(data=int_mean_sd,aes(type,median_int,color=type),position="dodge")+
  scale_color_npg()+
  guides(color=F)+
  # geom_errorbar(aes(ymax=upper,ymin=lower),position='dodge',width=0.2)+
  labs(x='Interaction Type',y='Median Interaction Strength')

# scatterplot mean vs. sd (removing intraspecies interactions and young macrocystis)
int_mean_sd_plot <- int_mean_sd %>%
  filter(type != "intraspecies", effect != "ymac", mod != "ymac")%>%
  ggplot(aes(mean_int,sd_int))+
  geom_point(aes(color=type,shape=type,fill=type),size=5)+
  geom_smooth(method="lm",se=F,col="black",show.legend = F)+
  geom_vline(xintercept=0,linetype=2)+
  # geom_encircle(aes(fill=type),col=NA,alpha=0.3,expand=0.1)+
  scale_color_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  scale_fill_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  scale_shape_manual(values=c(15,16,17,18),name="")+
  guides(fill='none')+
  labs(x="Mean Interaction Strength",y="SD Interaction Strength")+
  theme(legend.position = c(0.2,0.8))
# ggsave("plots/int_mean_sd.png",plot=int_mean_sd_plot,dpi=500)
# ggsave("plots/int_mean_sd.pdf",plot=int_mean_sd_plot)
int_mean_sd_plot

# Mean vs. range (95%)

int_mean_range_plot <- int_mean_sd %>%
  filter(type != "intraspecies", effect != "ymac", mod != "ymac")%>%
  ggplot(aes(abs_mean,y=upper-lower))+
  geom_point(aes(color=type,shape=type,fill=type),size=5)+
  geom_smooth(method="lm",se=F,col="black",linetype=2,show.legend = F)+
  # geom_vline(xintercept=0,linetype=2)+
  # geom_encircle(aes(fill=type),col=NA,alpha=0.3,expand=0.1)+
  scale_color_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  scale_fill_manual(values=c("darkorange1","orangered2","darkorchid1","palegreen3","skyblue1"),name="")+
  scale_shape_manual(values=c(15,16,17,18),name="")+
  guides(fill='none')+
  labs(x="Mean Interaction Strength",y="Range Interaction Strength")+
  theme(legend.position = c(0.8,0.8),
        legend.background = element_rect(color="black"))
# ggsave("plots/int_mean_range.png",plot=int_mean_range_plot,h=5,w=6)
# ggsave("plots/int_mean_range.pdf",plot=int_mean_sd_plot)
int_mean_range_plot


# CV
spp.only.mod.coeffs %>%
  filter(!is.na(type))%>%
  filter(type != "intraspecies")%>%
  group_by(type) %>%
  summarise(abs_mean=mean(abs(value)),sd_int=sd(value,na.rm=T),cv_int=abs_mean/sd_int*100)%>%
  ungroup()%>%
  ggplot(aes(type,cv_int))+
  geom_col()+
  labs(x="Interaction Type",y="CV of Measured Interactions")

  # summarise(mean_cv=mean(cv_int),sd_cv=sd(cv_int),upper=mean_cv+sd_cv/sqrt(n())*1.96,lower=mean_cv-sd_cv/sqrt(n())*1.96)%>%
# geom_errorbar(aes(ymax=upper,ymin=lower),position="dodge",width=0.25)+
```

### Bidirectional interactions (is the effect of A on B the same as B on A)
```{r bidirectional}
int_mean_sd %>%
  mutate(rev_effect=mod,rev_mod=effect) %>%
  left_join(int_mean_sd,by=c("rev_effect"="effect","rev_mod"="mod"))-> int_mean_sd2

int_mean_sd2 %>%
  filter(type.x %in% c('algal competition','urchin competition'),type.y %in% c('algal competition','urchin competition'))%>%
  ggplot(aes(mean_int.x,mean_int.y))+
  geom_point()+
  geom_smooth(method="lm")+
  geom_abline(slope=1,intercept=0,linetype=2)+
  geom_errorbar(aes(ymin=lower.y,ymax=upper.y))+
  geom_errorbarh(aes(xmin=lower.x,xmax=upper.x))+
  labs(x='Effect of A on B',y='Effect of B on A')
```

### Within-model cross correlation of effects

```{r cross correlation of effect}
cc_effects <- purrr::map(c("mac","purp","lam","ymac","red","pter"),function(x){
  spp.only.mod.coeffs %>% filter(mod==x,effect!='const') %>%
    select(time,period,effect,value)%>%spread(effect,value) %>%
    left_join(select(westend,one_of(phys.vars),period),by="period")%>%distinct()%>%
    select(-time,-period)%>%
    cor(use="complete.obs")
})
names(cc_effects) <- c("mac","purp","lam","ymac","red","pter")
cc_effects_plot <- function(model,effect1,effect2){
  spp.only.mod.coeffs %>% filter(mod==model,effect%in%c(effect1,effect2)) %>%
    select(time,period,effect,value)%>%spread(effect,value)%>%
    left_join(select(westend,one_of(phys.vars),period),by="period")%>%distinct()%>%
    ggplot(aes_string(effect1,effect2))+geom_point()+geom_smooth(method='lm',se=F)
}
```

## Convergent Cross Mapping interactions with Physical Forcing

Now that we have reconstructed species interactions, we can try using CCM to establish the relationship between the strength of those interactions and physical drivers.

We first create a time series block of the reconstructed attractors, then find their best embedding dimension, followed by cross mapping the interactions to the physical variables

```{r ints block}
# create time series block of all interactions (later we could come back to this to deal with error)
interactions.block <- spp.only.mod.coeffs %>%
  filter(type != "intraspecies", !is.na(type))%>%
  select(time,period,mod,effect,value)%>%
  unite("effect_mod",effect,mod)%>%
  spread(effect_mod,value) %>%
  complete(time=full_seq(x=c(1,630),1))%>%
  # join physical variables
  left_join(select(westend,period,one_of(phys.vars)),by="period")%>%
  distinct()%>%
  ungroup()%>%
  # normalize
  mutate_at(vars(lam_mac:ymac_red),function(dens) {(dens-mean(dens,na.rm=T))/sd(dens,na.rm=T)})
```

```{r ints time series plot}
spp.only.mod.coeffs %>%
  filter(time %in% 1:63,type=="algal competition")%>%
  unite("interaction",effect,mod,sep="_")%>%
  ggplot(aes(time,value,color=interaction))+
  geom_line()+
  geom_point()+
  labs(x="period",y="interaction strength")
```


```{r simplex ints,eval=F}
# Run simplex projection for each species interaction
interaction_names <- colnames(interactions.block)[3:22]
interactions.simp.list <- list()

for(i in 2:length(interaction_names)) {
  x <- interaction_names[i]
  dat <- interactions.block %>% select(matches(x)) %>% as.data.frame()
  out <- simplex(as.numeric(dat[,1]),lib=as.matrix(westend.segs),E=2:15,silent=T) %>%
    mutate(int=x)
 interactions.simp.list[[x]] <- out
}

# Save best embedding dimensions
ints.bestE <- purrr::map_chr(interactions.simp.list,function(x) {
  temp <- x %>% filter(!is.na(rho))
  temp$E[temp$rho==max(temp$rho)]
})
purrr::map_chr(interactions.simp.list,function(x) {
  max(x$rho,na.rm=T)
})
```


```{r ccm, eval=F}
## CCM checking physical variables against interactions
# Rows hold predicted variables, columns hold forcing variables. In this case, the columns (forcing factors) are the physical variables, while the rows are the interactions
n_col <- length(phys.vars)
n_row <- dim(interactions.block)[2]-7
col_names <- phys.vars
row_names <- interaction_names
interactions.xmap_mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## CCM causation criterion 1: cross-map skill greater than zero
# matrix to store a bootstrapped p-value, measuring the probability that a given xmap is greater than zero (calculated as 1 minus the number of positive results for rho divided by the number of iterations)
interactions.p1.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## CCM causation criterion 2: evidence for convergence
# similarly, matrix to store a bootstrapped p-value, this time a t-test value between library size 10 and library size 500, to see if the rho at large library is significantly greater than the rho at small library size (i.e., looking for convergence).
interactions.p2.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

# if both p1 and p2 are positive, indicate overall significant causal signal
interactions.ptot.mat <- array(NA,dim=c(n_row,n_col),dimnames=list(row_names,col_names))

## Run CCM for each combination of variables
for(i in 1:n_row) {
  for(j in 1:n_col) {
      # remember, we use the best embedding dimension for the target variable (the variable we're cross-mapping to, i.e. the putative forcing variable, in this case the physical variables)
      tempE= westend.bestE[col_names[j]]
      temp <- ccm(interactions.block,lib=as.matrix(westend.segs),pred=as.matrix(westend.segs),E=tempE,lib_column= 2+i,target_column = 2+length(interaction_names)+j,
                  lib_sizes = c(10,500),num_samples=100,replace=T,silent=T,RNGseed = 41389)
      # mean rho at library size 500
      rhomeans <- temp %>% ccm_means()
      interactions.xmap_mat[i,j] <- rhomeans$rho[rhomeans$lib_size==500]
      
      # first p-value (greater than zero? at library size 500)
      p1 <- temp %>% filter(lib_size==500) %>% 
        mutate(pos=ifelse(rho>0,1,0)) %>%
        summarise(p=(1-sum(pos)/n()))
      interactions.p1.mat[i,j] <- as.numeric(p1)
      
      # second p-value (rho at lib-size 500 greater than rho at lib-size 10? By more than 0.1?)
      p2 <- t.test(temp$rho[temp$lib_size==10],temp$rho[temp$lib_size==500])$p.value
      if((rhomeans$rho[rhomeans$lib_size==500]-rhomeans$rho[rhomeans$lib_size==10])<0.1) p2 <- 0
      interactions.p2.mat[i,j] <- as.numeric(p2)
      
      # overall significance (both p1 and p2 signficant at alpha 0.05)
      interactions.ptot.mat[i,j] <- ifelse(p1<0.05 & p2<0.05,1,0)
   }
}

rm(n_col,n_row,col_names,row_names,p1,p2,tempE,temp,rhomean)

# keep only signficant cross-mappings
interactions.xmap_mat <- interactions.xmap_mat*interactions.ptot.mat %>% as.data.frame()
interactions.xmap_rast <- interactions.xmap_mat %>% 
  mutate(predictee=row.names(interactions.xmap_mat)) %>% 
  gather(key=predictor,value=rho,-predictee)

# If rho is zero, replace with NA (no significant causal signal)
interactions.xmap_rast$rho[interactions.xmap_rast$rho==0] <- NA

# Names for plotting to distinguish biological and physical variables
interactions.xmap_rast <- interactions.xmap_rast %>% 
  mutate(force.name=namekey$plotting[match(predictor,namekey$short)])

## plot
interactions.xmap_all_plot <- ggplot(interactions.xmap_rast,aes(x=force.name,y=predictee,fill=rho)) +
  geom_raster() +
  scale_fill_gradient(low = "#9AFF9A", high = "#548B54", space = "Lab", na.value = "grey50", 
      guide = "colourbar",limits=c(0,0.75),breaks=c(0.25,0.5,0.75),name=expression(paste(rho, "(skill)"))) +
  ggtitle("Interaction Convergent Cross Mapping") +
  xlab("Predictor (Forcing Variable)") +
  ylab("Predicted Variable") +
  theme(text=element_text(color="black"),
        plot.background = element_rect(fill="white"),
        axis.text=element_text(color="black"),
    axis.text.x=element_text(angle = 90, hjust = 1,vjust=0.1),
    panel.border = element_blank())

interactions.xmap_all_plot
# ggsave("plots/ccm_ints_phys.png",plot=interactions.xmap_all_plot,width=6,height=5)
```

### Multivariate S-maps with Interactions

```{r multivariate smaps, eval=F}
ints.causal.vars <- purrr::map(interaction_names, function(x) {
  interactions.xmap_rast %>%
    filter(predictee==x,!is.na(rho))->out
  out <- out$predictor
  out
})

names(ints.causal.vars)=interaction_names

# apply s-maps
ints.multi.mods <- purrr::map(interaction_names,function(x) {
  if(length(ints.causal.vars[[x]])==0) return(NULL)
  else(smap_multi(interactions.block,westend.segs,x,ints.causal.vars[[x]]))
})
names(ints.multi.mods) <- interaction_names

purrr::map_dbl(ints.multi.mods, function(x) {
x$model$rho
})

```

## References